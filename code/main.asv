k_neighbours=9;

reduced_dim=2;

%theta=180.0*rand(no_of_angles,1);
% theta = randi([0 179],1,35);
theta = 0:5:179;

% https://in.mathworks.com/help/images/ref/phantom.html
image = phantom('Modified Shepp-Logan',200);

R = radon(image, theta);

% Applying fourier slice theorem.
% http://www.cs.uoi.gr/~cnikou/Courses/Digital_Image_Processing/Chapter_05c_Image_Restoration_(Reconstruction_from_Projections).pdf
FTvecs = zeros(size(R));
for i=1:length(R)
    FTvecs(i,:) = fft(R(i,:));
end

% Y = slle(X, k_neighbours, reduced_dim);

[D,N] = size(X);
    fprintf(1,'LLE running on %d points in %d dimensions\n',N,D);


%% STEP1: COMPUTE PAIRWISE DISTANCES & FIND NEIGHBORS 
fprintf(1,'-->Finding %d nearest neighbours.\n',K);

distance = zeros(N);
for i=1:N
    for j=1:N
        distance(i,j) = norm(X(:,i) -X(:,j));
    end
end

[~,index] = sort(distance);
neighborhood = index(2:(1+K),:);



%% STEP2: SOLVE FOR RECONSTRUCTION WEIGHTS
fprintf(1,'-->Solving for reconstruction weights.\n');

if(K>D) 
  fprintf(1,'   [note: K>D; regularization will be used]\n'); 
  tol=1e-3; % regularlizer in case constrained fits are ill conditioned
else
  tol=0;
end

W = zeros(K,N);
for ii=1:N
   z = X(:,neighborhood(:,ii))-repmat(X(:,ii),1,K); % shift ith pt to origin
   C = z'*z;                                        % local covariance
   C = C + eye(K,K)*tol*trace(C);                   % regularlization (K>D)
   W(:,ii) = C\ones(K,1);                           % solve Cw=1
   W(:,ii) = W(:,ii)/sum(W(:,ii));                  % enforce sum(w)=1
end


%% STEP 3: COMPUTE EMBEDDING FROM EIGENVECTS OF COST MATRIX M=(I-W)'(I-W)
fprintf(1,'-->Computing embedding.\n');

% M=eye(N,N); % use a sparse matrix with storage for 4KN nonzero elements
M = sparse(1:N,1:N,ones(1,N),N,N,4*K*N); 
for ii=1:N
   w = W(:,ii);
   jj = neighborhood(:,ii);
   M(ii,jj) = M(ii,jj) - w';
   M(jj,ii) = M(jj,ii) - w;
   M(jj,jj) = M(jj,jj) + w*w';
end

% CALCULATION OF EMBEDDING
disp(distance);
options.disp = 1; options.issym = 1; 
[Y,eigenvals] = eigs(M,d+1,0,options);
% [Y, eigenvals] = eigs(M, d+1, 1e-2, options);

Y = Y(:,2:d+1)'*sqrt(N); % bottom evect is [1,1,1,1...] with eval 0


fprintf(1,'Done.\n');

angles_slle = atand(Y(1,:)./Y(2,:));

img = iradon(R, angles_slle);
imshow(mat2gray(img));

